---
title: "Lecture 7"
author: "Brad McNeney"
date: '2017-02-28'
output: beamer_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Tidying data with the tidyverse

```{r, warning=FALSE, message=FALSE}
library(tidyverse) # loads dplyr, ggplot2, tidyr, etc
```


- Reading: Hadley Wickham's article on tidy data, available
from GitHub (Notes folder) or canvas.
    - Today's notes closely follow the `tidyr` vignette.

- "Tidy" data is ready for analysis, with one row for
each sampled unit and columns for the variables measured 
on the units.
    - Often classify variables as "explanatory" or "response"
    
- Tabular data and repeated measures data are often not 
in tidy form.

- Examples:
    - Tabular data on new tuberculosis cases from WHO
    - Repeated measures from Billboard Top 100
    
## Tuberculosis (TB) cases

\footnotesize
```{r}
tb <- read.csv("tb.csv",stringsAsFactors=FALSE)
dim(tb)
tb[1:4,1:6]
names(tb)[1:20]
```

## Structure of TB table

\small

- First column is 2-letter country code, second is year,
third is number of new cases for that country/year.
- Then come TB counts for different gender/age categories.
    - `new_sp` is "new cases by positive pulmonary smear assay"
    - gender is `m` or `f`
    - two special age categories 0-4, 5-14,
    - age categories 0-14, 15-24, 25-34, 35-44, 45-54, 
    55-65, 65+, unknown (`u`)
- Gender/age columns are not variables, they are data
on the observed units.
- Tidy data would have one row for each country, year, gender
and age category, with a column of counts 

## Billboard Top 100 rankings of songs

\scriptsize
```{r}
bb <- read.csv("billboard.csv",stringsAsFactors = FALSE)
dim(bb)
bb[1:3,1:6]
names(bb)[c(1:10,ncol(bb))]
```

## Structure of the Billboard table

- Columns `year` through `date.peaked` describe the song,
then `x1st.week` through `x76th.week` are the 
chart positions for the first through 76th weeks. 
    - If a song is on the chart for less than 76 weeks, its position is `NA` for any missing weeks.
- Weeks are not variables, they are the time data for the 
time series.

## Tidying the Billboard data

- Main step is to consolidate, or "gather" 
ranking in the different
weeks into a `rank` variable. 
- Before gathering, will select/rename some of the variables.
- After gathering, will create some new variables and 
sort the data frame.

## Select and rename

- Won't need `time` or `genre`. 
    - `select()` from `dplyr` can use `-` to de-select
- Rename `artist.inverted`
    - `rename()` from `dplyr` takes arguments of the form
    `newname = oldname`

\footnotesize

```{r}
bb %>% select(-time,-genre) %>% 
  rename(artist = artist.inverted) -> bb
```

## Gather the weeks into a "long" version of the Billboard data

\small

- Leave each song info variable as-is.
- The data, or "values", are the chart positions.
- The weeks are descriptors or "keys" for these values.
- We want to create key-value pairs for each observation.
    - There will be missing values, which we can remove.
- The `gather()` function from `tidyr` gathers specified
columns into keys (e.g., week) and values (e.g., rank).

## `gather()` for the Billboard data

\scriptsize
```{r}
bblong <- gather(bb,week,rank,x1st.week:x76th.week,na.rm=TRUE)
head(bblong,n=4)
```

## More cleaning suggested in the vignette

\small

- Extract week numbers from `week` variable
- Coerce `date.entered` to a `Date` object
- Calculate the date of each ranking based on 
the date it entered the charts and the week.
- Sort ("arrange") on artist, track and week.

\scriptsize
```{r, warning=FALSE, message=FALSE}
bblong %>% mutate(week = parse_number(week),
              date = as.Date(date.entered) + 7*(week-1)) %>%
  select(-date.entered) %>% # don't need date.entered anymore
  arrange(artist,track,week) -> bb
head(bb,n=3)
```

## Tidying the TB data

- Recall structure of the data: country, year, count of new cases, counts of new cases by 
gender/age categories.
```{r}
names(tb)[1:10]
```

- Main step is to "gather" TB prevalence in the different
gender/age categories into a count variable.
    - Complicated by the coding of gender/age categories
- Before gathering, will remove unneeded variables and
add country names to supplement 2-letter codes.


## Remove variables

- Won't need overall count
- Special categories 0-4 and 5-14 overlap with 0-14 so remove
- Age unknown not useful for analysing trends, so remove 

\scriptsize
```{r}
tb <- select(tb,-new_sp, -contains("04"), -contains("514"),
             -new_sp_mu, -new_sp_fu)
tb[1:3,1:10]
```

## Add country names to supplement country codes

\footnotesize

- I found a translation of the ISO-2 country codes at
[http://data.okfn.org/data/core/country-list] and saved
as `countryCodes.csv` in the `Notes` folder. 
    - Exercise: Find out which ISO-2 codes are in `tb` but not in 
    `countryCodes.csv`, google the missing codes, and 
    add the country names to `cc` manually.
```{r}
cc <- read.csv("countryCodes.csv",stringsAsFactors = FALSE)
# cc has columns "Name" and "Code". "Code" matches "iso2" in tb
```

- Exercise: Find out which ISO-2 codes are in `tb` but not in 
`countryCodes.csv`, google the missing codes, and 
add the country names to `cc` manually.

\scriptsize

```{r}
cc <- rbind(cc, data.frame(Name=c("Netherlands Antilles","Yugoslavia"),
                          Code=c("AN","YU")))
tb <- inner_join(cc,tb,by = c("Code" = "iso2")) 
tb[1:2,1:6]
```


## Gather counts for demographic groups

\footnotesize

- Create demographic variable `demog` and count variable `count` 
by gathering over all variables except `Name`, `Code` and `year`.

```{r}
tblong <- gather(tb,demog,count,-Name,-Code,-year,na.rm=TRUE)
head(tblong)
```

## Separate gender from age category.

\small

- First remove `new_sp_`, then separate result on first column (`help(separate)`)
```{r}
maxlen <- max(nchar(tblong$demog))
tblong %>% mutate(demog = substr(demog,8,maxlen)) %>%
  separate(demog, into=c("gender","agecat"),sep=1) -> tb
head(tb)
```


